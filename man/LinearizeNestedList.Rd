% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/LinearizeNestedList.R
\name{LinearizeNestedList}
\alias{LinearizeNestedList}
\title{Flatten Nested Lists to Get Index  Paths to Items}
\source{
https://sites.google.com/site/akhilsbehl/geekspace/articles/r/linearize_nested_lists_in_r
}
\usage{
LinearizeNestedList(NList, LinearizeDataFrames = FALSE, NameSep = "/",
  ForceNames = FALSE)
}
\arguments{
\item{NList}{A list of objects or a dataframe.}

\item{LinearizeDataFrames}{A boolean denoting whether NList is a data frame to be converted to a list.}

\item{NameSep}{A character that serves as separator between levels of nested list}

\item{ForceNames}{A boolean denoting whether LinearizeNestedList should return a named path to items in NList.}
}
\value{
LinearList: Flat named list
}
\description{
"Implements a recursive algorithm to linearize nested lists upto any
arbitrary level of nesting (limited by R's allowance for recursion-depth).
By linearization, it is meant to bring all list branches emanating from
any nth-nested trunk upto the top-level trunk s.t. the return value is a
simple non-nested list having all branches emanating from this top-level
branch.
}
\details{
Since dataframes are essentially lists a boolean option is provided to
switch on/off the linearization of dataframes. This has been found
desirable in the author's experience.
Also, one'd typically want to preserve names in the lists in a way as to
clearly denote the association of any list element to it's nth-level
history. As such we provide a clean and simple method of preserving names
information of list elements. The names at any level of nesting are
appended to the names of all preceding trunks using the `NameSep` option
string as the seperator. The default `/` has been chosen to mimic the unix
tradition of filesystem hierarchies. The default behavior works with
existing names at any n-th level trunk, if found; otherwise, coerces simple
numeric names corresponding to the position of a list element on the
nth-trunk. Note, however, that this naming pattern does not ensure unique
names for all elements in the resulting list. If the nested lists had
non-unique names in a trunk the same would be reflected in the final list.
Also, note that the function does not at all handle cases where `some`
names are missing and some are not.

Clearly, preserving the n-level hierarchy of branches in the element names
may lead to names that are too long. Often, only the depth of a list
element may only be important. To deal with this possibility a boolean
option called `ForceNames` has been provided. ForceNames shall drop all
original names in the lists and coerce simple numeric names which simply
indicate the position of an element at the nth-level trunk as well as all
preceding trunk numbers."
}
\author{
: Akhil S. Bhel
}
